# Ch2. 파이썬스러운(pythonic) 코드


- EWD831 : 왜 넘버링은 0 부터 시작해야 하는가? ([링크](https://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html))


- 파이썬 스러운 코드를 작성해야 하는 이유
  - 관용적인 방식으로 코드를 작성했을 때 일반적으로 더 나은 성능을 낸다
  - 실수를 줄이고 문제의 본질에 보다 집중할 수 있다.

## 학습목표

- 인덱스와 슬라이스 이해, 인덱싱 가능한 객체를 올바른 방식으로 구현
- 시퀀스와 이터러블 구현
- 컨텍스트 관리자를 만드는 모법 사례 연구
- 매직 메서드를 사용해 보다 관용적인 코드 표현
- 파이썬에서 부작용을 유발하는 흔한 실수 피하기

------

## 1. 인덱스와 슬라이스

### 1-1. 인덱스와 슬라이스

- tuple[1:7:2] → range와 같은 효과
- slice(1, 7, 2) 를 전달해줘도 됨

### 1-2. 자체 시퀀스 생성

- 위의 기능들은 `__getitem__` 이라는 매직 메서드 덕분에 동작
- myobject[key]와 같은 형태를 사용할 때 호출되는 메서드 key에 해당하는 대괄호 안의 값을 파라미터로 전달
- 시퀀스는 `__getitem__` 과 `__len__` 을 모두 구현하는 객체이므로 **반복이 가능**
- 리스트, 튜플, 문자열
- 클래스가 표준 라이브러리 객체를 감싸는 래퍼인 경우
  - 기본 객체에 가능한 많은 동작 위임 가능
- 래퍼도 아니고 내장 객체를 사용하지도 않는 경우
  - 범위로 인덱싱하는 결과는 해당 클래스와 같은 타입의 인스턴스여야 한다.
  - slice에 의해 제공된 범위는 마지막 요소는 제외해야 한다.

------


## 2. 컨텍스트 관리자(context manager)

- with 문
- 관심사를 분리하고 독립적으로 유지되어야하는 코드를 분리하는 좋은 방법

### 2-1. 컨텍스트 관리자 구현

- contextlib 모듈
- contextlib.contextmanager 데코레이터
  - 해당 함수의 코드를 컨텍스트 관리자로 변환
  - 함수는 제너레이터라는 특수한 함수의 형태여야 함
  - 이 함수는 코드의 문장을 `__enter__` 와 `__exit__` 매직 메서드로 분리

예제

- 컨텍스트 매니저를 작성하면 기존 함수를 **리팩토링하기 쉬운 장점**이 있다.

- contextlib.ContextDecorator 클래스

- 컨텍스트 관리자 안에서 실행될 함수에 데코레이터를 적용하기 위한 뢱을 제공하는 믹스인 클래스

  - 믹스인 클래스란

    다른 클래스에서 필요한 기능만 섞어서 사용할 수 있도록 메서드만을 제공하는 유틸리티 형태의 클래스

예제

- contextlib.suppress
  - util 패키지
  - 제공한 예외 중 하나가 발생한 경우에는 실패하지 않도록 한다.

------


## 3. 프로퍼티, 속성과 객체 메서드의 다른 타입들

- 다른 언어는 public, private, protected 프로퍼티를 가진다.
- 파이썬 객체의 **모든 프로퍼티와 함수**는 **public**이다.
- 강제사항은 없지만 몇 가지 규칙 존재
  - 밑줄로 시작하는 속성은 해당 객체에 대해 private을 의미
  - 외부에서 호출하지 않기를 기대하는 것

### 3-1. 파이썬에서의 밑줄

- 객체 자체에서만 생성되고 호출자는 이 속성에 접근하지 않아야 한다.
- 내부에서만 사용되고 바깥에서는 호출되지 않아서 동일한 인터페이스를 유지
- 언제든 필요한 경우 한전하게 리팩토링할 수 있어야 함

밑줄 두개를 사용한 경우

- 이름 맹글링(name magling)

### 3-2. 프로퍼티

- 객체에 값을 저장해야 할 경우 일반적인 속성(attribute)을 사용할 수 있음
- 프로퍼티를 사용하는 것이 좋은 선택
- 프로퍼티는 객체의 **어떤 속성에 대한 접근을 제어하려는 경우** 사용

예제

- 프로퍼티는 명령-쿼리 분리 원칙(command and query seperation -CC08)을 따르기 위한 좋은 방법

------




## 4. 이터러블 객체

- 반복 가능한 객체
- iter() ([파이썬 공식문서](https://docs.python.org/3.10/library/functions.html?highlight=iter#iter))
- 파이썬은 고수준에서 두 가지를 차례로 검사
  - 객체가 `__next__` 나 `__iter__` 이터레이터 메서드 중 하나를 포함하는지
  - 객체가 시퀀스이고 `__len__` 과 `__getitem__` 를 모두 가졌는지(폴백 매커니즘)

### 4-1. 이터러블 객체 만들기

- 객체를 반복하려고 하면 파이썬은 해당 객체의 `iter()` 함수를 호출
- for 문은 **StopIteration** 예외가 발생할 때까지 `next()`를 호출하는 것과 같음
- 예제

### 4-2. 시퀀스 만들기

- 이터러블을 사용하면 메모리를 적게 사용하지만 n번째 요소를 얻기 위한 시간복잡도는 **O(n)**
- 시퀀스로 구현하면 메모리는 더 많이 사용하지만( 모든 것을 한 번에 보관) 특정 인덱싱의 시간복잡도는 O(1)로 상수에 가능

------



## 5. 컨테이너 객체

- 컨테이너는 `__contains__` 메서드를 구현한 객체
- 일반적으로 Boolean을 반환
- in 키워드가 발견될 때 호출됨
  - element in container
  - ⇒ container.**contains**(element)
- 예제

------



## 6. 객체의 동적인 속성

- `__getattr__` 매직 메서드를 사용해 객체에서 속성을 얻는 방법을 제어할 수 있음
- 객체에 찾고 있는 속성이 없는 경우 속성(myattribute)의 이름을 파라미터로 전달하여 `__getattr__` 이라는 추가(extra)메서드가 호출됨
- 이러한 동적인 메서드를 구현할 때는 **AttributeError를 발생시켜야 함**

------



## 7. 호출형(callable) 객체

- 함수처럼 동작하는 객체를 정의하면 매우 편리. ex) 데코레이터
- `__call__` 매직 메서드는 객체를 일반 함수처럼 호출할 수 있다.
- 여기에 전달된 모든 파라미터는 `__call__` 매서드에 그대로 전달됨
- 객체에는 상태가 있기 때문에 **함수 호출 사이에 정보를 저장**할 수 있음

---



## 매직메서드 요약

| 문장                                   | 매직 메서드                                              | 파이썬 컨셉                |
| -------------------------------------- | -------------------------------------------------------- | -------------------------- |
| obj[key]<br />obj[i:j]<br />obj[i:j:k] | `__getitem__(key)`                                       | 첨자형(subscriptable) 객체 |
| with obj: ...                          | `__enter__` / `__exit__`                                 | 컨텍스트 관리자            |
| for i in obj: ...                      | `__inter__` / `__next__` <br />`__len__` / `__getitem__` | 이터러블 객체<br />시퀀스  |
| obj.<attribute>                        | `__getattr__`                                            | 동적 속성 조회             |
| obj(*args, **kwargs)                   | `__call__(*arg, **kwargs)`                               | 호출형(callable) 객체      |

---



## 8. 파이썬에서 유의할 점

### 8-1. 변경 가능한(mutable) 파라미터의 기본 값

- 변경 가능한 객체를 함수의 기본 인자로 사용하면 안 됨
- 기본 초기 값으로 None을 사용하고 함수 본문에서 기본 값을 할당



### 8-2. 내장(built-in) 타입 확장

- collections 모듈을 사용해 리스트, 문자열, 딕셔너리와 같은 내장 타입 확장 가능
- collections.UserDict, UserList, UserString

- Cpython 과 Pypy의 차이([Pypy공식문서](https://doc.pypy.org/en/latest/cpython_differences.html#subclasses-of-built-in-types))

---
