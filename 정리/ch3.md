# Ch3. 좋은 코드의 일반적인 특징

- 코드가 디자인이고, 디자인이 코드
- 클린코드의 궁극적인 목표는 코드를 가능한 **견고**하고 **결함을 최소화**하고 **완전히 자명**하도록 하는 것

## 학습목표

- 견고한 소프트웨어의 개념 이해
- 작업 중 잘못된 데이터를 다루는 방법
- 새로운 요구 사항을 쉽게 받아들이고 확장할 수 있는 유지보수가 쉬운 소프트웨어 설계
- 재사용 가능한 소프트웨어 설계
- 개발팀의 생산성을 높이는 효율적인 코드 작성

---



## 1. 계약에 의한 디자인

- 소프트웨어는 사용자가 직접 호출하거나 코드의 다른 부분에서 호출

- 컴포넌트는 기능을 숨겨 캠슐화하고 함수를 사용할 고객에게는 

  API

  를 노출해야 함

  - API를 디자인할 때 예상되는 입력, 출력, 부작용을 **문서화**해야 함
  - 그러나 문서화가 런타임 시의 소프트웨어 동작까지 **강제할 수는 없음**

### 1-1. 계약에 의한 디자인(Design by Contract)

- 관계자가 기대하는 바를 암묵적으로 코드에 삽입하는 대신 양측이 동의하는 계약을 먼저 한 다음, 계약을 어겼을 경우는 명시적으로 왜 계속할 수 없는지 예외를 발생시키는 것
- 이 책에서 말하는 **계약**은 소프트웨어 컴포넌트 간의 통신 중에 반드시 지켜져야 할 몇 가지 규칙을 강제하는 것
- 계약은 주로 사전조건과 사후조건을 명시하지만 때로는 불변식과 부작용을 기술함

------

- 사전조건(precondition): 코드가 실행되기 전에 체크해야 하는 것들
- 사후조건(postcondition) : 사전조건과 반대로 여기서는 함수 반환 값의 유효성 검사가 수행됨
- 불변식(invariant)
- 부작용(side-effect)

### 1-2. 파이썬스러운 계약

- pep-316([link](https://www.python.org/dev/peps/pep-0316/)) - 연기(defered) 상태
- 일반적인 디자인 원칙하에 파이썬으로 구현할 수 있는 방법(저자)
  1. 메서드, 함수 및 클래스에 `RuntimeError` 예외 또는 `ValueError` 예외를 발생시키는 제어 메커니즘을 추가하는 것
  2. 문제를 특정하기 어려울 경우, 사용자 정의 예외를 만드는 것이 바람직
  3. **데코레이터나 더 작은 함수를 생성**하여 사전/사후조건에 대한 검사 부분과 핵심 기능 부분의 코드를 격리된 상태로 유지하는 것이 좋음

### 1-3. 계약에 의한 디자인(DbC) - 결론

- 디자인 원칙의 주된 가치는 문제가 있는 부분을 효과적으로 식별할 수 있음
- 코드가 더욱 견고해짐
  - 각 컴포넌트는 자체적으로 제약 조건과 불변식을 관리
  - 이러한 불변식이 유지되는 한 프로그램이 정상 동작함
- 무엇을 검증할 것인지 신중히 검토해야 함

------



## 2. 방어적(Defensive) 프로그래밍

- DbC: 계약에서 예외를 발생시키고 **실패하게 되는 모든 조건을 기술**
- 방어적 프로그래밍: 객체, 함수 또는 메서드와 같은 코드의 모든 부분을 유효하지 않은 것으로부터 스스로 보호할 수 있게 하는 것
- 방어적 프로그래밍은 여러 측면을 고려한 기술
- **다른 디자인 원칙과 결합된 경우** 특히 유용(보완 관계 가능)

### 2-1. 에러 핸들링(Error Handling)

- 예상되는 에러에 대해서 실행을 계속할 수 있을지 아니면 극복할 수 없는 오류여서 프로그램을 중단할지를 결정하는 것
- 오류가 발생하기 쉬운 상황에서 사용, 일반적으로 데이터 입력 확인 시 자주 사용
- 에러 처리 방법

1. **값 대체**

- 결과 값을 안전한 다른 값으로 대체
- **견고성과 정확성 간의 trade-off**

2. **예외 처리**

- 예외적인 상황을 명확하게 알려주고 원래의 비즈니스 로직에 따라 흐름을 유지하는 것
- 프로그램이 꼭 처리해야 하는 정말 예외적인 비즈니스 로직을 `except` 블록과 혼합하여 사용하면 상황이 더욱 악화될 수 있음
- 호출자가 알아야만 하는 실질적인 문제가 있을 경우에는 예외를 발생시켜야 함

> **함수가 너무 많은 예외가 있다**

- 응집력이 약함(캡슐화가 안되어 있다)

- 많은 책임을 가지게 됨
- 분할화 해야 함(작은 단위의 함수)

### 2-2. 파이썬의 예외처리 권장사항

1. **올바른 수준의 추상화 단계에서 예외 처리**
   - 예외는 오직 한 가지 일을 하는 함수의 한 부분이어야 함
   - 함수가 처리하는(발생시키는) 예외는 캡슐화된 로직과 일치해야 함
   - 예제
2. **Traceback 노출 금지**

- 보안을 위한 고려 사항
- 예외를 처리할 때 오류가 너무 중요하다면 전파해도 됨
- 파이썬에서 traceback은 **매우 유용하고 많은 디버깅 정보를 포함**

> [**주의**] 그와 동시에 이 정보는 악의적인 사용자에게도 중요 정보 유출 발생 위험

1. **비어있는 except 블록 지양**

- 너무 방어적이여서 아무것도 하지 않은 채로 조용히 지나쳐버리는 비어있는 except 블록
- 파이썬의 안티패턴([realpython blog](https://realpython.com/the-most-diabolical-python-antipattern/))

> **대안**

- 구체적인 예외 사용
- except 블록에서 실제 오류 처리
- 가장 좋은 방법은 위의 두 항목 동시 적용

1. **원본 예외 포함**

- 오류 처리시 메시지를 변경할 경우, 원래 예외를 포함하는 것이 좋음
- `raise <e> from <original_exception>` 구문 사용

### 2-3. 어설션(Assertion) 사용하기

- 절대로 일어나지 않아야 하는 상황에서 사용
- assert 문에 사용된 표현식은 **불가능한 조건**을 의미
- 이 상태가 된다는 건 소프트웨어에 결함이 있음을 의미
- 잘못된 시나리오에 도달할 경우 프로그램이 더 큰 피해를 입지 않도록 하는 것
- 비즈니스 로직과 섞거나 소프트웨어의 제어 흐름 메커니즘으로 사용해서는 안된다.
  - `**AssertionError 에외를 처리하지 않는다**`

```python
result= condition.holds()
assert result > 0, "에러 {0}".format(result)
```

------



## 3. 관심사의 분리(Seperation of Concerns, SOC)

- 참고링크([blog](https://medium.com/@smartbosslee/관심사의-분리-separation-of-concerns-soc-8a8d09df066d))
- 책임이 다르면 컴포넌트, 계층, 모듈로 분리되어야 함
- 프로그램의 각 부분은 기능의 **일부분(관심사)에 대해서만 책임을 지며** 다른 부분에 대해서는 알 필요 없음
- 목표 : **파급 효과를 최소화하여 유지보수성을 향상**

> **파급(ripple) 효과**: 어느 지점에서의 변화가 전체로 전파되는 것

### 3-1. 응집력(cohesion)과 결합력(coupling)

- **응집력**
- **결합력**

---



## 4. 개발 지침 약어



EAFP vs LBYL([reference](https://devblogs.microsoft.com/python/idiomatic-python-eafp-versus-lbyl/))





## 5. 컴포지션과 상속

- 코드를 재사용하는 올바른 방법은 여러 상황에서 동작 가능하고 쉽게 조합할 수 있는 응집력 높은 객체를 사용하는 것
- 동시에 결합력을 최소한으로 줄이는 것



### 5-1. 상속이 좋은 선택인 이유



### 5-2. 상속 안티패턴



### 5-3. 파이썬의 다중상속

![3장.파이썬의다중상속](md-images/3%EC%9E%A5.%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%9D%98%EB%8B%A4%EC%A4%91%EC%83%81%EC%86%8D.PNG)



> **믹스인(minin)**



---



## 6. 함수와 메서드의 인자

파이썬 함수의 인자 전달 메커니즘과 SW 엔지니어링에서의 모범 사례에서 발견되는 일반적인 원칙을 살펴본다.



### 6-1. 파이썬의 함수 인자 동작방식

> 인자는 함수에 어떻게 복사되는가



> 가변인자



### 6-2. 함수 인자의 개수

> 함수 인자와 결합력



> 많은 인자를 취하는 작은 함수의 서명



---



## 7. 소프트웨어 디자인 우수 사례 결론



### 7-1. 소프트웨어의 독립성(orthogonality)

